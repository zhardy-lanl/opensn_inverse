#!/usr/bin/env python3# -*- coding: utf-8 -*-"""Created on Wed Jun  5 22:30:44 2024@author: jean.ragusa"""import csvimport numpy as npimport matplotlib.pyplot as pltplt.close('all')# %% Read the CSV filedef read_file(basename, group_list):    u = []    for g in group_list:        formatted_number = f"{g:03d}"        filename = basename.replace("AAA", formatted_number)        with open(filename, 'r') as file:            reader = csv.reader(file)            # Skip the header            next(reader)            # Read the rest of the lines as numbers            data = []            for row in reader:                data.append([float(num) for num in row])        # Convert the list of lists to a NumPy array        arr = np.array(data)        x, y, z = arr[:, 0], arr[:, 1], arr[:, 2]        u.append(arr[:, -1])    return z, u[0]# %% load dataimport syssigma_t = 0.1c = 0.5if len(sys.argv) > 1:    if sys.argv[1] in ['scat', 'abs']:        c = 0.5 if sys.argv[1] == 'scat' else 0.0sigma_s = c * sigma_tviz = any(arg == '--viz' for arg in sys.argv)group_list = [0]if c < 1e-8:    pure_absorber = Trueelse:    pure_absorber = Falseif pure_absorber:    z, flx_ref = read_file('abs/forward_ref_density_phi_g000_m00.csv', group_list)    z, flx_cst = read_file('abs/forward_init_density_phi_g000_m00.csv', group_list)    z, flx_per = read_file('abs/forward_perturb_density_phi_g000_m00.csv', group_list)    z, flx_adj = read_file('abs/adjoint_init_density_phi_g000_m00.csv', group_list)else:    z, flx_ref = read_file('scat/forward_ref_density_phi_g000_m00.csv', group_list)    z, flx_cst = read_file('scat/forward_init_density_phi_g000_m00.csv', group_list)    z, flx_per = read_file('scat/forward_perturb_density_phi_g000_m00.csv', group_list)    z, flx_adj = read_file('scat/adjoint_init_density_phi_g000_m00.csv', group_list)plt.figure()plt.plot(z, flx_ref, label='ref', marker='+', ms=2)plt.plot(z, flx_cst, label='cst')plt.plot(z, flx_per, label='per')plt.tight_layout()plt.grid(True)plt.legend()plt.figure()plt.plot(z, flx_adj, label='adj')plt.tight_layout()plt.grid(True)plt.legend()rho_ref = 2.0rho_init = 2.1if pure_absorber:    # S4 leak_ref = 1.251353102887    leak_ref = 1.2371887541035    # S4 leak_cst = 1.2042000754935    leak_cst = 1.1907115945127    # drho = 0.01    # S4 leak_per = 1.1996426275513    # drho = 0.001    # S4 leak_per = 1.2037430751964    # S32leak_per = 1.1902609755143    drho = 0.0001    leak_per = 1.1906665203378else:    leak_ref = 2.4479962917199    leak_cst = 2.3814231857552    drho = 0.0001    leak_per = 2.3813581007654Fobj = 0.5 * (leak_ref - leak_cst) ** 2Fper = 0.5 * (leak_ref - leak_per) ** 2# %% compute numerical value of the gradientdF = (Fper - Fobj) / drhoprint('FD for dFobj =', dF, "\n-----------------\n")# %% compute gradient with datafrom scipy.interpolate import CubicSplinef_spline_phi_adj = CubicSpline(z, flx_adj)f_spline_phi_cst = CubicSpline(z, flx_cst)from scipy.integrate import quadintegrand = lambda x: f_spline_phi_adj(x) * f_spline_phi_cst(x)int_adj, _ = quad(f_spline_phi_adj, z[0], z[-1], limit=5000)int_adjfor, _ = quad(integrand, z[0], z[-1], limit=5000)print('int_adj   = ', int_adj)print('int_adjfor= ', int_adjfor)print('flx_cst =', np.mean(flx_cst))print('flx_cst times int_adj =', np.mean(flx_cst) * int_adj)# < psi_adj, sigt psi_for > #  = < psi_adj, sigt phi_for/2 >  when forward problem is the constant solution#  = sigt phi_for/2 * < psi_adj, 1 >  when forward problem is the constant solution#  = sigt phi_for/2 * (int_space phi_adj)gradient_tot = sigma_t * np.mean(flx_cst) / 2 * int_adj# < psi_adj, - int_angle (sigs/2 psi_for) > # < psi_adj, - sigs/2 phi_for) > # - sigs/2 phi_for * < psi_adj, 1 > when forward problem is the constant solution# - sigs/2 phi_for * (int_space phi_adj)gradient_sca = sigma_s * np.mean(flx_cst) / 2 * int_adjprint('\ninner prod tot=', gradient_tot)print('inner prod sca=', gradient_sca)print('\n---------------\ninner prod =', gradient_tot - gradient_sca, "\n")if viz:    plt.show()